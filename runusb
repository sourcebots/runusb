#!/usr/bin/env python3

import logging
import os
import re
import select
import subprocess
from enum import Enum
from typing import Callable, Dict, Iterator, NamedTuple  # noqa: F401

TypeOpenHandler = Callable[[str], subprocess.Popen]
TypeCloseHandler = Callable[[str, subprocess.Popen], None]


LOGGER = logging.getLogger('runusb')

PROC_FILE = '/proc/mounts'
ROBOT_FILE = 'main.py'
SPAWN_IMAGE = '/mnt/rootmirror'
UPDATE_FILENAME = 'update.tar.xz'
ROBOTD_LOCATION = '/var/robotd'


Mountpoint = NamedTuple('Mountpoint', [
    ('mountpoint', str),
    ('filesystem', str),
])


VERBOTEN_FILESYSTEMS = (
    'cgroup',
    'configfs',
    'debugfs',
    'devpts',
    'devtmpfs',
    'hugetlbfs',
    'mqueue',
    'proc',
    'sysfs',
)


def get_machinename(path):
    return re.sub(r'[^\w]', r'_', path).strip('_')


class USBType(Enum):
    ROBOT = 'ROBOT'
    UPDATE = 'UPDATE'
    INVALID = 'INVALID'  # We dont care about this drive


def detect_usb_type(mountpoint: str) -> USBType:
    # subpaths of the root image are excluded
    if mountpoint.startswith(SPAWN_IMAGE):
        return USBType.INVALID

    # Check for existence of update file
    if os.path.exists(os.path.join(mountpoint, UPDATE_FILENAME)):
        return USBType.UPDATE

    # Check for the existence of the robot code
    if os.path.exists(os.path.join(mountpoint, ROBOT_FILE)):
        return USBType.ROBOT

    return USBType.INVALID


class FSTabReader(object):
    def __init__(self) -> None:
        self.handle = open(PROC_FILE)

    def __enter__(self):
        self.handle.__enter__()
        return self

    def __exit__(self, *args, **kwargs):
        return self.handle.__exit__(*args, **kwargs)

    def close(self):
        self.handle.close()

    def read(self) -> Iterator[Mountpoint]:
        self.handle.seek(0)

        for line in self.handle:
            (_, mountpoint, filesystem, _, _, _) = line.split(' ')

            yield Mountpoint(
                mountpoint=mountpoint,
                filesystem=filesystem,
            )

    def watch(self, timeout=None):
        _, _, changed = select.select([], [], [self.handle], timeout)

        if changed:
            LOGGER.debug("Detected change in procfile")

        return bool(changed)


def open_update_robot_process(path: str) -> subprocess.Popen:
    return subprocess.Popen(
        ['sb-update', path],
        stdin=subprocess.DEVNULL,
    )


def open_run_robot_code_process(path: str) -> subprocess.Popen:
    command = [
        'systemd-nspawn',
        '--private-network',
    ]

    # Specify the root directory for the nspawn container
    command.extend(('--directory', SPAWN_IMAGE))

    # Bring in any requested bind mounts
    command.extend(('--bind', ROBOTD_LOCATION))

    # Mount a tmpfs as /tmp
    command.extend(('--tmpfs', '/tmp'))

    # Bind-mount the actual path
    command.extend(('--bind', path))

    # Attach a machine ID, use the path as the ID
    command.extend(('--machine', get_machinename(path)))

    # Run as our limited user
    command.extend(('--user', 'runusb'))

    # Run the autorun file with bash -c
    command.extend(('/bin/bash', '-c'))

    # cd to the mountpoint and run the autorun file
    command.append(
        'cd "{mountpoint}" ; script --quiet -ec "python3 {autorun}" -f log.txt'.format(
            mountpoint=path,
            autorun=ROBOT_FILE,
        ),
    )

    return subprocess.Popen(command, stdin=subprocess.DEVNULL)


def kill_robot_process(path: str, process: subprocess.Popen) -> None:
    # With the mountpoint now missing the only sensible thing to do is
    # to die horribly.
    command = ('machinectl', 'terminate', get_machinename(path))
    subprocess.call(command)
    process.wait(timeout=5)
    try:
        process.kill()
    except ProcessLookupError:
        pass


def noop_close(path, process):
    """
        We don't actually want to kill in the case of the update process.
        Could lead to the robot in a broken state!
    """
    pass


class AutorunProcessRegistry(object):
    TYPE_HANDLERS = {
        USBType.ROBOT: open_run_robot_code_process,
        USBType.UPDATE: open_update_robot_process,
    }  # type: Dict[USBType, TypeOpenHandler]

    TYPE_CLOSE_HANDLER = {
        USBType.ROBOT: kill_robot_process,
        USBType.UPDATE: noop_close,
    }  # type: Dict[USBType, TypeCloseHandler]

    def __init__(self) -> None:
        self.mountpoint_processes = {}  # type: Dict[str, subprocess.Popen]
        self.mountpoint_types = {}  # type: Dict[str, USBType]

    def update_filesystems(self, mountpoints: Iterator[Mountpoint]) -> None:
        actual_mountpoint_paths = {
            x.mountpoint
            for x in mountpoints
            if self._is_viable_mountpoint(x)
        }

        expected_mountpoint_paths = {
            x for x in self.mountpoint_processes.keys()
        }

        # Handle newly detected filesystems
        for new_mountpoint_path in (
            actual_mountpoint_paths
            - expected_mountpoint_paths
        ):
            self._detect_new_mountpoint_path(new_mountpoint_path)

        # Handle now-dead filesystems
        for old_mountpoint_path in (
            expected_mountpoint_paths
            - actual_mountpoint_paths
        ):
            self._detect_dead_mountpoint_path(old_mountpoint_path)

    def _detect_new_mountpoint_path(self, path: str) -> None:
        LOGGER.info("Found new mountpoint: %s", path)
        usb_type = detect_usb_type(path)
        type_handler = self.TYPE_HANDLERS[usb_type]
        process = type_handler(path)
        LOGGER.info("  -> launched process")
        self.mountpoint_processes[path] = process
        self.mountpoint_types[path] = usb_type

    def _detect_dead_mountpoint_path(self, path: str) -> None:
        LOGGER.info("Lost mountpoint: %s", path)
        usb_type = self.mountpoint_types[path]
        process = self.mountpoint_processes[path]
        close_handler = self.TYPE_CLOSE_HANDLER[usb_type]
        close_handler(path, process)
        LOGGER.info("  -> closed process")
        del self.mountpoint_processes[path]
        del self.mountpoint_types[path]

    def _is_viable_mountpoint(self, mountpoint: Mountpoint) -> bool:
        # Drop restricted types
        if mountpoint.filesystem in VERBOTEN_FILESYSTEMS:
            LOGGER.debug(
                "Disregarding filesystem %s due to forbidden filesystem "
                "type %s",
                mountpoint.mountpoint,
                mountpoint.filesystem,
            )

            return False

        # Sanity: never consider the root filesystem
        if mountpoint.mountpoint == '/':
            return False

        # Defer to the declared filter by path
        return detect_usb_type(mountpoint.mountpoint) is not USBType.INVALID


def main():
    logging.basicConfig(level=logging.DEBUG)

    fstab_reader = FSTabReader()

    registry = AutorunProcessRegistry()

    # Initial pass (in case an autorun FS is already mounted)
    registry.update_filesystems(fstab_reader.read())

    try:
        while True:
            if fstab_reader.watch():
                registry.update_filesystems(fstab_reader.read())
    except KeyboardInterrupt:
        # Tell the registry that all filesystems were unmounted, which has the
        # effect of making it do cleanup.
        registry.update_filesystems([])  # type: ignore


if __name__ == '__main__':
    main()
